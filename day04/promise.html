<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>promise</title>
</head>

<body>
    <!-- 
        promise 分析:
            1. promise实例 内部有三种状态
                1. pending 状态
                2. resolved / fulfilled 成功状态
                3. rejected 失败状态
            2. 用法：是往Promise 构成函数中传递一个回调函数
                1. 参数一： resolve 也是一个函数
                2. 参数二： jeject 也是函数
                3. 状态只能修改一次
            3. Promise.then 方法，pending 不触发回调
                1. 接收两个回调函数
                2. 当promise对象的状态为成功状态，触发第一个回调函数
                3. 当promise对象的状态为失败状态，触发第二个回调函数
                4. 回调函数接收一个参数，参数是 Promise对象调用成功/失败的函数，所传递的参数
            4. Priomise.catch 方法 pending 不触发
                1. 触发失败的回调函数，接收失败回调函数作为参数
            5. Promise.finally 方法 pending 不触发回调
                1. 接收一个回调函数，
                2. 根据 promise 的状态进行触发，但是 pending 不触发
            6. Promise 构造函数的方法
                1. Promise.resolve() // 创建一个成功状态的promise
                2. Promise.reject() // 创建一个失败状态的promise
                3. new Promise() // 创建一个初始化状态的promise
                4. Promise.all // 
        原理解析：
            mdn
            then 是一个异步方法，里面的回调函数都是异步执行的
            then 第一次被调用时，默认时 pending 状态，所以不会触发then 方法里面 的回调函数
            then(onResolved,onRejected)
                promise的状态是 resolved 时， 异步调用 onResolved 函数
                promise的状态是 rejected 时， 异步调用 onRejected 函数
                promise的状态是 pending 时， 将onResolved 和 onRejected 存储到一个数据结构中，将来会调用
                异步回调函数的参数是 调用成功或失败的函数传递过来的值，并且在实例对象上
            then方法的链式调用
                第二个then方法内部触发的异步回调函数看上一个then方法
                    1. 如果上一个then方法，没有返回值，那么默认是成功状态
                    2. 如果上一个then方法，返回的是一个promise 对象，那么就看promise的状态
                    3. 如果上一个then方法抛出异常，那么就是 失败状态
                返回的值是上一个then方法的返回值


     -->

    <script>
        MyPromise.prototype.then = function (onResolved, onRejected) {
            const that = this;
            let mypromise = null;

            if (that.status === 'resolved') {
                // 如果是成功状态
                mypromise = new MyPromise((resolve, reject) => {
                    setTimeout(() => {
                        // 2. 如果上一个then方法，返回的是一个promise 对象，那么就看promise的状态
                        try {
                            const promise = onResolved(that.value)
                            if (promise instanceof MyPromise) {
                                // 说明 是 mypromise 对象
                                promise.then(resolve, reject) // 调用 方法将 mypromise 的状态改为 成功 / 失败
                            } else {
                                // 1. 如果上一个then方法，没有返回值，那么默认是成功状态
                                resolve(promise) // 返回值看上一个then的返回值
                            }
                        } catch (e) {
                            // 3. 如果上一个then方法抛出异常，那么就是 失败状态
                            reject(e)
                        }
                    }, 0);
                })
            } else if (that.status === 'rejected') {
                // 如果是失败状态
                mypromise = new MyPromise((resolve, reject) => {
                    setTimeout(() => {
                        // 2. 如果上一个then方法，返回的是一个promise 对象，那么就看promise的状态
                        try {
                            const promise = onRejected(that.value)
                            if (promise instanceof MyPromise) {
                                // 说明 是 mypromise 对象
                                promise.then(resolve, reject) // 调用 方法将 mypromise 的状态改为 成功 / 失败
                            } else {
                                // 1. 如果上一个then方法，没有返回值，那么默认是成功状态
                                resolve(promise) // 返回值看上一个then的返回值
                            }
                        } catch (e) {
                            // 3. 如果上一个then方法抛出异常，那么就是 失败状态
                            reject(e)
                        }
                    }, 0);
                })
            } else if (that.status === 'pending') {
                // 如果是初始化状态
                mypromise = new MyPromise((resolve, reject) => {
                    /* 
                        由于一上来是 pending 状态，会执行这里的操作，但是他既没有执行 resolve 也没有执行 reject ，那么永远就都是pending
                        状态，第二个then 就永远不会触发
                     */
                    that.callBacks.onResolved = onResolved;
                    that.callBacks.onRejected = onRejected;
                })
            }

            return mypromise // 为了实现链式调用
        }

        function MyPromise(exec) {
            this.status = 'pending' // 初始化状态
            this.value = undefined; // 初始化默认值
            const that = this; // 缓存this
            this.callBacks = {} // 存储异步回调函数的数据结构 

            try { // 一但出错，就会调用 失败回调
                exec(resolve, reject)
            } catch (error) {
                reject(error)
            }

            /* 成功的回调 */
            function resolve(value) {
                if (that.status === 'pending') { // 状态只能修改一次
                    that.status = 'resolved' // 修改实例的状态
                    that.value = value // 赋值
                    if (that.callBacks.onResolved) { // 解决bug, 
                        setTimeout(() => {
                            that.callBacks.onResolved(value); // 调用异步回调函数   
                        });
                    }
                }
            }
            /* 失败的回调 */
            function reject(reason) {
                if (that.status === 'pending') {
                    that.status = 'rejected'
                    that.value = reason;
                    if (that.callBacks.onRejected) {
                        setTimeout(() => {
                            that.callBacks.onRejected(reason); // 调用异步回调函数
                        });
                    }
                }
            }

        }



        const mypromise = new MyPromise((resolve, reject) => {
            setTimeout(() => {
                resolve(111)
            }, 2000);
        })
        mypromise
            .then((value) => {
                console.log(value)
                return 111
            })
            .then(value => {
                console.log(value)
            })
    </script>
</body>

</html>